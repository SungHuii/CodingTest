# 문제 : 벌집
# 위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 
# 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다.
# 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지
# (시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.

# 입력
# 첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.

# 출력
# 입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.

# 풀이
# 내 생각 : 중앙에서 1로 시작하면 인접한 방의 갯수가 6개이다. 
# 중앙방 1개 + 인접한 방 6개 = 7개가 되고, 세번째는 13개의 방, 네번째는 21개의 방이 된다.
# 1 7 13 21 사이의 숫자를 계산해보면, 6 6 8 이고, 다섯번째는 30개의 방이 되는데, 
# 첫번째~ n번째줄로 늘어날 때 인접한 방의 갯수가 늘어나는 공식을 알아내야 함
# 1 7 13 21 30 40 51 63 76 90 105 121 138 156 175 195 216 238 261 285 310 336 363 391 420 450 481 513 546 580 615 651 688 726 765 805 846 888 931 975 1020 1066 1113 1161 1210 1260 1311 1363 1416 1470 1525 1581 1638 1696 1755 1815 1876 1938 2001 2065 2130 2196 2263 2331 2400 2470 2541 2613 2686 2760 2835 2911 2988 3066 3145 3225 3306 3388 3471 3555 3640 3726 3813 3901 3990 4080 4171 4263 4356 4450 4545 4641 4738 4836 4935 5035 5136 5238 5341 5445 5550 5656 5763 5871 5980 6090 6201 6313 6426 6540 6655 6771 6888 7006 7125 7245 7366 7488 7611 7735 7860 7986 8113 8241 8370 8500 8631 8763 8896 9030 9165 9301 9438 9576 9715 9855 9996
# 각 줄마다 방의 갯수가 두번째줄을 제외하고 2씩 증가하는 것을 알 수 있음
# 6 6 8 10 12 14...
# 그럼 해당 줄의 방의 갯수만큼의 2씩 늘어나는 배열을 만들어서 배열에 숫자를 넣어주고,
# 몇번째 배열에 해당 숫자가 들어가있는지 계산해서 출력하면 된다.

# 해설
n = int(input())
k = 1
end = 1
while end < n:
    k += 1
    end = 1 + 3*k*(k1)
print(k)

# 문제: 중앙 방(1)에서 시작해 바깥으로 육각형 겹(링)이 늘어날 때,
#      주어진 방 번호 N까지 최소 몇 개의 방(시작/끝 포함)을 지나가는지 구하라.
#
# 관찰:
#   - k번째 겹(1부터 시작)의 마지막 번호(최대값)는: end(k) = 1 + 3*k*(k-1)
#       k=1 -> 1
#       k=2 -> 7
#       k=3 -> 19
#       k=4 -> 37
#       ...
#   - N이 end(k) 이하가 되는 최소 k가 곧 정답이다.
#     (즉, 중앙에서 k겹 이동하면 N이 있는 겹까지 도달)
#
# 알고리즘:
#   1) k = 1, end = 1로 시작
#   2) end < N 인 동안 k를 1씩 증가시키며 end = 1 + 3*k*(k-1)을 갱신
#   3) 반복을 멈춘 k를 출력
# 시간 복잡도:
#   - k는 대략 O(sqrt(N)) 수준이며, N ≤ 1e9에서도 k ≈ 18,300 정도로 매우 작음.
#   - 따라서 단순 반복으로도 충분히 빠름.

# import sys

# N = int(sys.stdin.readline().strip())

# k = 1       # 현재 겹(1겹부터 시작: 1만 포함하는 겹)
# end = 1     # k번째 겹의 최대 번호 (초기: 1)

# end가 N에 도달하거나 넘어설 때까지 겹을 확장
# while end < N:
#     k += 1
#     end = 1 + 3 * k * (k - 1)

# print(k)